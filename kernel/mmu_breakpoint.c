#include <linux/init.h>
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/ptrace.h>
#include <linux/signal.h>
#include <linux/smp.h>
#include <linux/sched/signal.h>
#include <linux/mm_types.h>
#include <linux/slab.h>
#include <linux/vmalloc.h>
#include <linux/uaccess.h>
#include <linux/kallsyms.h>
#include <asm/traps.h>
#include <asm/tlbflush.h>
#include <asm/io.h>
#include <asm/pgtable.h>

// Define PTE_TYPE_FAULT if not already defined
#ifndef PTE_TYPE_FAULT
#define PTE_TYPE_FAULT 0x0
#endif

#ifndef PTE_TYPE_MASK
#define PTE_TYPE_MASK 0x3  // Lowest 2 bits for type
#endif

#include "mmu_breakpoint.h"
#include "single_step.h"
#include "inline_hook/p_lkrg_main.h"
#include "inline_hook/p_hook.h"
#include "inline_hook/utils/p_memory.h"
#include "version_control.h"

#ifdef CONFIG_MMU_BREAKPOINT_MODE

// 全局断点列表
static LIST_HEAD(mmu_breakpoints);
static DEFINE_SPINLOCK(mmu_bp_lock);
static DEFINE_MUTEX(mmu_bp_mutex);

// 函数指针
static void (*user_enable_single_step_)(struct task_struct *);
static void (*user_disable_single_step_)(struct task_struct *);

// 刷新特定页的TLB
static void flush_page(struct vm_area_struct *vma, unsigned long addr) {
    flush_tlb_page(vma, addr);
}

// 查找断点
static struct mmu_breakpoint *find_breakpoint(pid_t tgid, unsigned long addr) {
    struct mmu_breakpoint *bp;
    
    spin_lock(&mmu_bp_lock);
    list_for_each_entry(bp, &mmu_breakpoints, list) {
        if (bp->tgid == tgid && addr >= bp->addr && addr < bp->addr + bp->size) {
            spin_unlock(&mmu_bp_lock);
            return bp;
        }
    }
    spin_unlock(&mmu_bp_lock);
    return NULL;
}

// 通过PID查找断点，供single_step.c使用
struct mmu_breakpoint *find_breakpoint_by_pid(pid_t tgid, unsigned long addr) {
    struct mmu_breakpoint *bp;
    
    spin_lock(&mmu_bp_lock);
    list_for_each_entry(bp, &mmu_breakpoints, list) {
        if (bp->tgid == tgid && (addr == 0 || (addr >= bp->addr && addr < bp->addr + bp->size))) {
            spin_unlock(&mmu_bp_lock);
            return bp;
        }
    }
    spin_unlock(&mmu_bp_lock);
    return NULL;
}

// 钩子函数声明
static void before_handle_pte_fault(hook_fargs1_t *fargs, void *udata);

// 钩子函数：处理页面错误 - Before
static void before_handle_pte_fault(hook_fargs1_t *fargs, void *udata) {
    struct vm_fault *vmf = (struct vm_fault *)fargs->arg0;
    struct mmu_breakpoint *bp;
    unsigned long addr = vmf->address;
    bool is_hit = false;
    pid_t target_tgid;

    // The fault occurs in the context of the accessing process (e.g., process_vm_readv),
    // but the vm_fault struct contains information about the target memory space.
    // We must use the owner of the mm_struct to find the correct breakpoint.
    if (!vmf->vma || !vmf->vma->vm_mm || !vmf->vma->vm_mm->owner) {
        return;
    }
    target_tgid = vmf->vma->vm_mm->owner->tgid;
    
    bp = find_breakpoint(target_tgid, addr);
    if (!bp) {
        // Not our breakpoint, let the original function handle it
        return;
    }
    
    // Determine if it's a "hit" we care about
    if (vmf->flags & FAULT_FLAG_INSTRUCTION) {
        if (bp->access_type & BP_ACCESS_EXECUTE) {
            is_hit = true;
            PRINT_DEBUG("[+] mmu_bp: EXECUTE fault at 0x%lx, IP: 0x%lx\n", addr, task_pt_regs(current)->pc);
        }
    } else if (vmf->flags & FAULT_FLAG_WRITE) {
        if (bp->access_type & BP_ACCESS_WRITE) {
            is_hit = true;
            PRINT_DEBUG("[+] mmu_bp: WRITE fault at 0x%lx\n", addr);
        }
    } else { // Read fault
        if (bp->access_type & BP_ACCESS_READ) {
            is_hit = true;
            PRINT_DEBUG("[+] mmu_bp: READ fault at 0x%lx\n", addr);
        }
    }

    // Restore the page to its original state so the original handler can process it
    pte_t *ptep = pte_offset_map(vmf->pmd, vmf->address);
    if (!ptep) {
        // Cannot resolve PTE, something is wrong. Do nothing and let original handle it.
        return;
    }
    khack_set_pte_at(vmf->vma->vm_mm, vmf->address, ptep, bp->original_pte);
    pte_unmap(ptep);
    flush_page(vmf->vma, vmf->address);
    
    // Only enable single-step to re-arm the breakpoint if the fault was
    // generated by a thread within the target process itself.
    if (current->tgid == bp->tgid) {
        if (is_hit) {
            bp->hit_count++;
        }
        
        if (user_enable_single_step_) {
            user_enable_single_step_(current);
        }
        PRINT_DEBUG("[+] mmu_bp: Single-step enabled for self-inflicted fault in TID %d at 0x%lx\n", current->pid, vmf->address);
        
        // For target process faults, skip the original handler to ensure single-step works correctly
        fargs->skip_origin = 1;
        fargs->ret = 0;
    } else {
        // This fault was from an external process (like process_vm_readv).
        // We have restored the PTE. The original handler will now succeed.
        // The breakpoint is temporarily disarmed until the next single-step trap in the target process.
        PRINT_DEBUG("[+] mmu_bp: Handled external fault for TGID %d at 0x%lx. BP temporarily disarmed.\n", bp->tgid, vmf->address);
        
        // For external process faults, let the original handler run to avoid crashes
        fargs->skip_origin = 0;
    }
}

// 设置断点（移除页面存在位）
static int set_breakpoint(struct mmu_breakpoint *bp) {
    pte_t *ptep;
    
    ptep = virt_to_pte(bp->task, bp->addr);
    if (!ptep) {
        PRINT_DEBUG("[-] mmu_bp: Failed to get PTE for addr 0x%lx\n", bp->addr);
        return -EFAULT;
    }
    
    // 保存原始页表项
    bp->vma = find_vma(bp->task->mm, bp->addr);
    if (!bp->vma) {
        PRINT_DEBUG("[-] mmu_bp: Failed to find VMA for addr 0x%lx\n", bp->addr);
        return -EFAULT;
    }
    do {
        struct mm_struct *mm = bp->vma->vm_mm;
        pte_t pte;
        pte = *ptep;
        bp->original_pte = pte;

        if (!pte_present(pte)) {
            PRINT_DEBUG("[-] mmu_bp: Page at 0x%lx is not present, cannot set breakpoint.\n", bp->addr);
            return -EINVAL;
        }

        // Create a new PTE with the 'valid' and 'table' bits cleared, which causes a fault
        // This prevents the kernel from interpreting it as a swap entry
        pte = __pte(pte_val(pte) & ~PTE_TYPE_MASK);
        khack_set_pte_at(bp->task->mm, bp->addr, ptep, pte);
        flush_tlb_page(bp->vma, bp->addr);
    } while (0);
    
    // Lock the VMA to prevent the page from being swapped out
    if (bp->vma) {
        bp->vma->vm_flags |= VM_LOCKED;
        PRINT_DEBUG("[+] mmu_bp: Set VM_LOCKED for VMA to prevent swapping\n");
    }
    
    bp->is_active = true;
    PRINT_DEBUG("[+] mmu_bp: Breakpoint set for PID %d at 0x%lx\n", bp->tgid, bp->addr);
    return 0;
}

// 清除断点（恢复页面存在位）
static int clear_breakpoint(struct mmu_breakpoint *bp) {
    pte_t *ptep;
    
    if (!bp->is_active)
        return 0;
    
    ptep = virt_to_pte(bp->task, bp->addr);
    if (!ptep) {
        PRINT_DEBUG("[-] mmu_bp: Failed to get PTE for addr 0x%lx\n", bp->addr);
        return -EFAULT;
    }
    
    // 恢复原始页表项
    khack_set_pte_at(bp->task->mm, bp->addr, ptep, bp->original_pte);
    flush_page(bp->vma, bp->addr);
    
    // Unlock the VMA to restore original state
    if (bp->vma) {
        bp->vma->vm_flags &= ~VM_LOCKED;
        PRINT_DEBUG("[+] mmu_bp: Removed VM_LOCKED for VMA\n");
    }
    
    bp->is_active = false;
    PRINT_DEBUG("[+] mmu_bp: Breakpoint cleared for PID %d at 0x%lx\n", bp->tgid, bp->addr);
    return 0;
}


// 添加断点
static int add_breakpoint(pid_t pid, unsigned long addr, unsigned long size, int access_type) {
    struct mmu_breakpoint *bp;
    struct task_struct *task;
    pid_t tgid;
    int ret;
    
    // 获取任务结构
    task = get_pid_task(find_vpid(pid), PIDTYPE_PID);
    if (!task) {
        PRINT_DEBUG("[-] mmu_bp: Task not found for PID %d\n", pid);
        return -ESRCH;
    }
    
    // 获取线程组ID (TGID)
    tgid = task->tgid;
    put_task_struct(task);
    
    // 检查是否已存在
    if (find_breakpoint(tgid, addr)) {
        PRINT_DEBUG("[-] mmu_bp: Breakpoint already exists for TGID %d at 0x%lx\n", tgid, addr);
        return -EEXIST;
    }
    
    // 获取任务结构
    task = get_pid_task(find_vpid(pid), PIDTYPE_PID);
    if (!task) {
        PRINT_DEBUG("[-] mmu_bp: Task not found for PID %d\n", pid);
        return -ESRCH;
    }
    
    // 创建断点结构
    bp = kmalloc(sizeof(struct mmu_breakpoint), GFP_KERNEL);
    if (!bp) {
        put_task_struct(task);
        return -ENOMEM;
    }
    
    // 初始化断点
    bp->tgid = tgid;
    bp->addr = addr;
    bp->size = size;
    bp->access_type = access_type;
    bp->task = task;
    bp->is_active = false;
    bp->hit_count = 0;
    
    // 设置断点
    ret = set_breakpoint(bp);
    if (ret) {
        kfree(bp);
        put_task_struct(task);
        return ret;
    }
    
    // 添加到列表
    mutex_lock(&mmu_bp_mutex);
    list_add(&bp->list, &mmu_breakpoints);
    mutex_unlock(&mmu_bp_mutex);
    
    PRINT_DEBUG("[+] mmu_bp: Added breakpoint for TGID %d at 0x%lx (size: %lu, type: 0x%x)\n", 
               tgid, addr, size, access_type);
    return 0;
}

// 移除断点
static int remove_breakpoint(pid_t pid, unsigned long addr) {
    struct mmu_breakpoint *bp, *tmp;
    bool found = false;
    struct task_struct *task;
    pid_t tgid;
    
    // 获取任务结构以获取TGID
    task = get_pid_task(find_vpid(pid), PIDTYPE_PID);
    if (!task) {
        PRINT_DEBUG("[-] mmu_bp: Task not found for PID %d\n", pid);
        return -ESRCH;
    }
    tgid = task->tgid;
    put_task_struct(task);
    
    mutex_lock(&mmu_bp_mutex);
    list_for_each_entry_safe(bp, tmp, &mmu_breakpoints, list) {
        if (bp->tgid == tgid && addr >= bp->addr && addr < bp->addr + bp->size) {
            clear_breakpoint(bp);
            list_del(&bp->list);
            put_task_struct(bp->task);
            kfree(bp);
            found = true;
            break;
        }
    }
    mutex_unlock(&mmu_bp_mutex);
    
    if (!found) {
        PRINT_DEBUG("[-] mmu_bp: Breakpoint not found for TGID %d at 0x%lx\n", tgid, addr);
        return -ENOENT;
    }
    
    PRINT_DEBUG("[+] mmu_bp: Removed breakpoint for TGID %d at 0x%lx\n", tgid, addr);
    return 0;
}

// 清空所有断点
static int clear_all_breakpoints(void) {
    struct mmu_breakpoint *bp, *tmp;
    int count = 0;
    
    mutex_lock(&mmu_bp_mutex);
    list_for_each_entry_safe(bp, tmp, &mmu_breakpoints, list) {
        clear_breakpoint(bp);
        list_del(&bp->list);
        put_task_struct(bp->task);
        kfree(bp);
        count++;
    }
    mutex_unlock(&mmu_bp_mutex);
    
    PRINT_DEBUG("[+] mmu_bp: Cleared %d breakpoints\n", count);
    return 0;
}

// 公共接口实现
int handle_mmu_breakpoint_control(PMMU_BP_CTL ctl) {
    int ret = 0;
    
    PRINT_DEBUG("[+] mmu_bp: Control request - PID: %d, Addr: 0x%lx, Action: %d\n", 
               ctl->pid, ctl->addr, ctl->action);
    
    switch (ctl->action) {
        case 1: // 添加
            ret = add_breakpoint(ctl->pid, ctl->addr, ctl->size, ctl->access_type);
            break;
        case 2: // 移除
            ret = remove_breakpoint(ctl->pid, ctl->addr);
            break;
        case 3: // 清空
            ret = clear_all_breakpoints();
            break;
        default:
            ret = -EINVAL;
            break;
    }
    
    return ret;
}

int handle_mmu_breakpoint_list(pid_t tgid, PMMU_BP_INFO buffer, size_t *count) {
    struct mmu_breakpoint *bp;
    size_t found = 0;
    size_t capacity = *count;
    int ret = 0;
    
    mutex_lock(&mmu_bp_mutex);
    list_for_each_entry(bp, &mmu_breakpoints, list) {
        if (tgid == 0 || bp->tgid == tgid) {
            if (found < capacity) {
                MMU_BP_INFO info;
                info.pid = bp->tgid;  // 保持info.pid为tgid以兼容用户空间
                info.addr = bp->addr;
                info.size = bp->size;
                info.access_type = bp->access_type;
                info.is_active = bp->is_active;
                info.hit_count = bp->hit_count;
                
                if (copy_to_user(&buffer[found], &info, sizeof(MMU_BP_INFO))) {
                    ret = -EFAULT;
                    break;
                }
            }
            found++;
        }
    }
    mutex_unlock(&mmu_bp_mutex);
    
    *count = found;
    return ret;
}

bool is_mmu_breakpoint_active(pid_t tgid, unsigned long addr) {
    struct mmu_breakpoint *bp = find_breakpoint(tgid, addr);
    return bp && bp->is_active;
}

// 初始化函数
int mmu_breakpoint_init(void) {
    void *handle_pte_fault_addr;
    
    PRINT_DEBUG("[+] mmu_bp: Initializing MMU breakpoint system\n");
    
    // 解析符号
    user_enable_single_step_ = (void (*)(struct task_struct *))kallsyms_lookup_name("user_enable_single_step");
    user_disable_single_step_ = (void (*)(struct task_struct *))kallsyms_lookup_name("user_disable_single_step");
    
    if (!user_enable_single_step_ || !user_disable_single_step_) {
        PRINT_DEBUG("[-] mmu_bp: Failed to resolve required single-step symbols\n");
        return -ENOENT;
    }

    if (!P_SYM(p_sync_icache_dcache)) {
        P_SYM(p_sync_icache_dcache) = (void *)kallsyms_lookup_name("__sync_icache_dcache");
        if (!P_SYM(p_sync_icache_dcache)) {
            PRINT_DEBUG("[-] mmu_bp: Failed to resolve __sync_icache_dcache\n");
            return -ENOENT;
        }
    }

    handle_pte_fault_addr = (void *)kallsyms_lookup_name("handle_pte_fault");
    if (!handle_pte_fault_addr) {
        PRINT_DEBUG("[-] mmu_bp: Failed to find handle_pte_fault\n");
        return -ENOENT;
    }
    
    // 设置钩子 - 使用before钩子
    if (hook_wrap(handle_pte_fault_addr, 1, before_handle_pte_fault, NULL, NULL) != HOOK_NO_ERR) {
        PRINT_DEBUG("[-] mmu_bp: Failed to wrap handle_pte_fault()\n");
        return -1;
    }
    
    PRINT_DEBUG("[+] mmu_bp: MMU breakpoint system initialized successfully\n");
    return 0;
}

// 退出函数
void mmu_breakpoint_exit(void) {
    void *handle_pte_fault_addr;

    PRINT_DEBUG("[+] mmu_bp: Shutting down MMU breakpoint system\n");
    
    // 清空所有断点
    clear_all_breakpoints();
    
    // 移除钩子
    handle_pte_fault_addr = (void *)kallsyms_lookup_name("handle_pte_fault");
    if (handle_pte_fault_addr) {
        hook_unwrap(handle_pte_fault_addr, before_handle_pte_fault, NULL);
    }
    
    PRINT_DEBUG("[+] mmu_bp: MMU breakpoint system shutdown complete\n");
}
#endif
